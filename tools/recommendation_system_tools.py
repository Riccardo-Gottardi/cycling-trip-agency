import requests

import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MultiLabelBinarizer
import numpy as np


def get_pois_in_circular_area(lat, lon, radius_meters=1000, amenity_type="restaurant"):
    """
    Get POIs using Overpass API (OpenStreetMap data)
    
    Parameters:
    - lat, lon: coordinates of center point
    - radius_meters: search radius in meters
    - amenity_type: type of POI (restaurant, cafe, hospital, etc.)
    """
    
    # Overpass API query
    overpass_url = "https://overpass-api.de/api/interpreter"
    overpass_query = f"""
    [out:json];
    (
      node["amenity"="{amenity_type}"](around:{radius_meters},{lat},{lon});
      way["amenity"="{amenity_type}"](around:{radius_meters},{lat},{lon});
      relation["amenity"="{amenity_type}"](around:{radius_meters},{lat},{lon});
    );
    out center;
    """
    
    response = requests.get(overpass_url, params={'data': overpass_query})
    data = response.json()
    
    pois = []
    for element in data['elements']:
        poi = {
            'name': element.get('tags', {}).get('name', 'Unknown'),
            'type': element.get('tags', {}).get('amenity', ''),
            'lat': element.get('lat') or element.get('center', {}).get('lat'),
            'lon': element.get('lon') or element.get('center', {}).get('lon'),
            'tags': element.get('tags', {})
        }
        pois.append(poi)
    
    return pois


# -------------------------------------------------------------------
# --- 1. Data Setup (Simulated POI Database and User Preferences) ---
# -------------------------------------------------------------------

# Simulate a database of Points of Interest (POIs)
# In a real system, this would come from APIs like Google Places, OpenStreetMap, etc.
pois_data = {
    'poi_id': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'name': ['Historical Castle', 'Nature Reserve Trailhead', 'Local Brewery',
             'Art Museum', 'Scenic Lake Viewpoint', 'Traditional Windmill',
             'Botanical Garden', 'Mountain Pass Cafe', 'Ancient Ruins', 'Riverside Park'],
    'latitude': [52.079, 52.085, 52.070, 52.090, 52.065, 52.082, 52.073, 52.095, 52.078, 52.068],
    'longitude': [4.310, 4.325, 4.300, 4.315, 4.290, 4.330, 4.305, 4.320, 4.312, 4.298],
    'category': [
        ['historical', 'sightseeing'],
        ['nature', 'outdoor', 'trail'],
        ['food_drink', 'local'],
        ['culture', 'museum'],
        ['nature', 'sightseeing'],
        ['historical', 'sightseeing', 'local'],
        ['nature', 'culture'],
        ['food_drink', 'scenic'],
        ['historical', 'sightseeing'],
        ['nature', 'outdoor']
    ],
    'avg_rating': [4.5, 4.8, 4.2, 4.0, 4.7, 4.6, 4.3, 4.1, 4.4, 4.5],
    'difficulty_impact': [1, 3, 1, 1, 2, 1, 1, 2, 1, 2] # 1: Low impact, 3: High impact on route difficulty
}
pois_df = pd.DataFrame(pois_data)

# Simulate user preferences (this would be gathered by the User Input Agent)
user_preferences = {
    'interests': ['historical', 'nature', 'food_drink'],
    'max_detour_km': 5, # Maximum acceptable detour from the route for a POI
    'preferred_difficulty': 'moderate' # Could be 'easy', 'moderate', 'hard'
}

# Simulate a planned cycling route (simplified as a list of coordinates)
# In a real system, this would be generated by a Route Planning Agent
# For demonstration, let's assume a route near our POIs
planned_route = [
    {'latitude': 52.075, 'longitude': 4.305},
    {'latitude': 52.080, 'longitude': 4.315},
    {'latitude': 52.085, 'longitude': 4.320},
    {'latitude': 52.070, 'longitude': 4.295}
]

# ----------------------------------------------------------
# --- 2. Feature Engineering for POIs and User Interests ---
# ----------------------------------------------------------

# Convert categorical features (categories) into a one-hot encoded format
mlb = MultiLabelBinarizer()
poi_categories_encoded = mlb.fit_transform(pois_df['category'])
poi_categories_df = pd.DataFrame(poi_categories_encoded, columns=mlb.classes_, index=pois_df.index)

# Combine with other numerical features (e.g., avg_rating, difficulty_impact)
# We'll normalize numerical features if they are on very different scales, but for this example,
# we'll keep it simple.
poi_features = pd.concat([poi_categories_df, pois_df[['avg_rating', 'difficulty_impact']]], axis=1)

# Create a user interest vector
user_interest_vector = np.zeros(len(mlb.classes_))
for interest in user_preferences['interests']:
    if interest in mlb.classes_:
        user_interest_vector[mlb.classes_.tolist().index(interest)] = 1

# Add dummy values for avg_rating and difficulty_impact for user vector,
# as these are POI characteristics, not user preferences directly.
# We'll use 0 or a neutral value, or exclude them from similarity if only comparing categories.
# For simplicity, let's just make the user vector the same length as poi_features
user_feature_vector = np.concatenate([user_interest_vector, [0.0, 0.0]]) # Dummy values for avg_rating, difficulty_impact

# ----------------------------------------------------------
# --- 3. Recommendation Logic (POI Recommendation Agent) ---
# ----------------------------------------------------------

def haversine_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the distance between two points on Earth using the Haversine formula.
    Returns distance in kilometers.
    """
    R = 6371  # Earth radius in kilometers

    lat1_rad = np.radians(lat1)
    lon1_rad = np.radians(lon1)
    lat2_rad = np.radians(lat2)
    lon2_rad = np.radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = np.sin(dlat / 2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlon / 2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

    distance = R * c
    return distance

def recommend_pois(pois_df, poi_features, user_feature_vector, planned_route, user_preferences):
    recommendations = []

    # Calculate similarity between user interests and POI categories
    # Reshape user_feature_vector for cosine_similarity
    user_feature_vector_reshaped = user_feature_vector.reshape(1, -1)
    similarities = cosine_similarity(user_feature_vector_reshaped, poi_features.values)[0]

    pois_df['interest_similarity'] = similarities

    for index, poi in pois_df.iterrows():
        poi_lat, poi_lon = poi['latitude'], poi['longitude']

        # Find the closest point on the planned route to the POI
        min_distance_to_route = float('inf')
        for route_point in planned_route:
            dist = haversine_distance(poi_lat, poi_lon, route_point['latitude'], route_point['longitude'])
            if dist < min_distance_to_route:
                min_distance_to_route = dist

        # Check if POI is within acceptable detour distance
        if min_distance_to_route <= user_preferences['max_detour_km']:
            # Apply other filters based on user preferences and POI characteristics

            # Filter by difficulty impact (simplified logic)
            if user_preferences['preferred_difficulty'] == 'easy' and poi['difficulty_impact'] > 1:
                continue # Skip if too difficult for 'easy' preference
            elif user_preferences['preferred_difficulty'] == 'moderate' and poi['difficulty_impact'] > 2:
                continue # Skip if too difficult for 'moderate' preference

            recommendations.append({
                'poi_id': poi['poi_id'],
                'name': poi['name'],
                'category': poi['category'],
                'avg_rating': poi['avg_rating'],
                'distance_to_route_km': round(min_distance_to_route, 2),
                'interest_similarity': round(poi['interest_similarity'], 4)
            })

    # Sort recommendations by a combination of interest similarity and proximity
    # You can customize this sorting logic based on your desired weighting
    sorted_recommendations = sorted(
        recommendations,
        key=lambda x: (x['interest_similarity'] * 0.7 + (1 - x['distance_to_route_km'] / user_preferences['max_detour_km']) * 0.3),
        reverse=True
    )

    return sorted_recommendations

# Get recommendations
recommended_pois = recommend_pois(pois_df.copy(), poi_features, user_feature_vector, planned_route, user_preferences)

# ----------------------------------------------------
# --- 4. Output and Agentic Interaction Simulation ---
# ----------------------------------------------------

print("--- Cycling Trip POI Recommendation System ---")
print("\nUser Preferences:")
for key, value in user_preferences.items():
    print(f"- {key.replace('_', ' ').capitalize()}: {value}")

print("\nSimulated Planned Route:")
for i, point in enumerate(planned_route):
    print(f"  Point {i+1}: Lat {point['latitude']}, Lon {point['longitude']}")

print("\nRecommended Points of Interest:")
if recommended_pois:
    for i, poi in enumerate(recommended_pois[:5]): # Show top 5
        print(f"\n{i+1}. {poi['name']}")
        print(f"   Category: {', '.join(poi['category'])}")
        print(f"   Avg Rating: {poi['avg_rating']}")
        print(f"   Distance to Route: {poi['distance_to_route_km']} km")
        print(f"   Interest Similarity: {poi['interest_similarity']}")
else:
    print("No POIs found matching your criteria.")

# --- Further Agentic Steps (Conceptual) ---

print("\n--- Agentic Workflow Continuation ---")
print("\n* Refinement/Feedback Agent would now present these options to the user.")
print("  The user could say, 'I like the Historical Castle, but what about other food options nearby?'")
print("  This feedback would then trigger a re-evaluation of recommendations.")
print("\n* Information Retrieval Agent would fetch detailed info for selected POIs.")
print("  e.g., 'Historical Castle: Open 9 AM - 5 PM, Entrance Fee: â‚¬10. Rich history of the region...'")
print("\n* Trip Planning Agent would then integrate the selected POIs into the final itinerary,")
print("  potentially adjusting the route to optimally include them.")